Адаптивный лок
====================

| Название | mutex            |
| -------- | ---------------- |
| Баллы    | 4-8              |
| Дедлайн  | 07.11.2021 09:00 |

# Предыстория

Существует два основных подхода к реализации локов:

* Спинлоки
  * **Плюсы:** простота, малые накладные расходы на синхронизацию.
  * **Минусы:** во время ожидания крутятся в цикле, занимая процессор бесполезной работой.
* Мьютексы
  * **Плюсы:** не занимают процессор бесполезным циклом.
  * **Минусы:** большой оверхэд на системные вызовы и последующие переключения контекста.

Для быстрых критических секций хорошо подходят спинлоки, а для долгих &mdash; мьютексы. Вам предлагается реализовать лок, который хорошо ведёт себя в обоих случаях.

# Подготовка

* [futex](https://man7.org/linux/man-pages/man2/futex.2.html)
* [C atomics](https://en.cppreference.com/w/c/atomic)
* [std::atomic::wait](https://en.cppreference.com/w/cpp/atomic/atomic/wait), [std::atomic::notify_one](https://en.cppreference.com/w/cpp/atomic/atomic/notify_one)
* Слайды про примитивы синхронизации: [раз](https://docs.google.com/presentation/d/1_M8O1jZB-NVGJ5j41f54cf3SsdLju696Z-X0RH91IBU/edit?usp=sharing), [два](https://docs.google.com/presentation/d/1poyin44EnNCJyJQjFhYMRvcqbLV3Aociy4TELKRqOwQ/edit?usp=sharing)

Вам также может пригодиться [thread local storage](https://en.cppreference.com/w/cpp/language/storage_duration).

# Задание

Реализуйте адаптивный лок. Лок должен поддерживать следующие операции:

* `void lock()`
* `void unlock()`
* `bool try_lock()`

Адаптироваться ваш лок должен к следующим ситуациям:

* Критическая секция короткая.

  В этом случае, ожидая освобождения лока, достаточно крутиться в цикле, вызывая инструкцию `pause`, если вы выполняетесь на x86.

* Критическая секция короткая, но поток, владеющий локом, почему-то задержался. Например, его его снял с выполнения планировщик.

  В этом случае имеет смысл освободить ядро, вызвав `std::this_thread::yield()`.

* Долгая критическая секция.

  Для ожиданяи лока поток должен зануть на фьютексе.

Различать эти ситуации необходимо по времени, которое поток провёл в ожидании освобождения лока. Запоминать состояние между вызовами `lock` не нужно.

Таким образом, ожидая освобождения лока, поток сначала крутится в цикле `SPIN_ITERS` итераций, затем делает `yield`, затем засыпает на фьютексе.

Значение `SPIN_ITERS` подберите сами. Можно ориентироваться на следующие величины:

* Time slice в Linux: 750 мкс - 6 мс ([stackoverflow](https://stackoverflow.com/a/16402758)). Это время, которое выделяется планировщиком потоку до того, как он будет принудительно вытеснен.
* Context switch: 1-3 мкс (результат [lmbench](http://www.bitmover.com/lmbench/lat_ctx.8.html) на моём ноутбуке).
* System call: 10 нс - 2 мкс ([stackoverflow](https://stackoverflow.com/a/41783404)). Очень сильно зависит от сисколла. Для фьютекса я бы ожидал 200-300 нс.

## Memory effects

В терминах SC-DRF между вызовами `mutex.unlock()` в одном потоке и `mutex.lock()` в другом должно возникать отношение `synchronizes-with`. При этом эти операции (точнее, обращения к памяти внутри них) могут не входить в глобальный порядок `synchronization order`. Иначе говоря, `mutex.lock()` обладает семантикой `memory_order_acquire`, а `mutex.unlock()` &mdash; `memory_order_release`.

Вы можете использовать атомарные операции с `memory_order_seq_cst`, а можете попытаться расставить слабые memory orders и заработать дополнительный балл.

Не увлекайтесь! Корректный неоптимальный код гораздо лучше, чем оптимальный, но некорректный.

## Честность

Неформально: лок называется честным, если потоки проходят в критическую секцию в том же порядке, в котором они вызвали метод `lock()`. Так, ticket- и MCS-локи честные, а test-and-set-лок &mdash; нет. Честность является более строгим вариантом свободы от голодания. За неё вы можете заработать дополнительные 2 балла.

Ни futex, ни `std::atomic::notify_one` не дают гарантий на порядок пробуждения потоков.

Разрешается обеспечивать честность только в предположении, что число потоков не превосходит какой-то константы `N`, но `N` должно быть не меньше 16. Остальные свойства лока должны сохраняться и для большего числа потоков.

При реализации честного лока запрещается использовать `notify_all` или `FUTEX_WAKE` с параметром `val > 1`, а также будить в методе `unlock` более одного спящего потока каким-либо иным способом.

## Лишние системные вызовы

Рассмотрим мьютекс, основанный на TAS-спинлоке:

```cpp
void lock() {
    while (atomic_exchange(&lock_, 1)) {
        syscall(SYS_futex, &lock_, FUTEX_WAIT | FUTEX_PRIVATE_FLAG,
                           1, NULL, NULL, 0);
    }
}
```

При такой реализации захват свободного лока выполняется за одну атомарную операцию без системных вызовов. Но при освобождении лока придётся всегда делать syscall, так как мы не знаем, есть ли спящие потоки:

```cpp
void unlock() {
    atomic_store(&lock_, 0);
    syscall(SYS_futex, &lock_, FUTEX_WAKE | FUTEX_PRIVATE_FLAG,
                       1, NULL, NULL, 0);
}
```

За избегание системных вызовов при отсутствии спящих потоков вы получите дополнительный балл.

Эта функциональность встроена в `std::atomic::wait/notify`, но если вы на это полагаетесь, разберитесь, как там это реализовано:

* [libc++](https://github.com/llvm/llvm-project/blob/main/libcxx/src/atomic.cpp)

* [libstdc++](https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/atomic_wait.h)

# Реализация

Напишите свою реализацию в файле `mutex/mutex.hpp`.

Для вызова `pause` в цикле используйте функцию `pndc::cpu_relax()` из pndc/cpu.hpp или ассемблерную вставку.

Менять `mutex/tests/main.cpp` нельзя, за исключениям корректировки таймаутов. Если вдруг вы захотите добавить свои тесты, создайте отдельный файл и добавьте вызов `make_test` в `mutex/CMakeLists.txt`.

Код пушьте в ветку `mutex` и открывайте pull request в master. В описании **укажите**, какие **дополнительные свойства** вы реализовали.


# Разбалловка

| Свойства                                                 | Баллы |
| -------------------------------------------------------- | ----- |
| Адаптивный лок                                           | 4     |
| При отсутствии спящих потоков `FUTEX_WAKE` не вызывается | +1    |
| Правильно расставленные слабые memory orders             | +1    |
| Честность                                                | +2    |